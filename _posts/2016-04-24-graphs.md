---
layout:     post
title:      "数据结构 - 图论"
date:       2016-04-24 12:00:00
author:     "Lindz"
header-img: "img/9.jpg"
tags:
    - 数据结构
---

## (一) 基本概念

表示 "多对多" 的关系

图是由顶点和边组成的：(可以无边，但至少包含一个顶点)

* 一组顶点： 通常用  V (vertex) 表示顶点集合
* 一组边：通常用 E（Edge）表示边的集合

图可以分为有向图和无向图，在图中：

* (v, w) 表示无向边，即 v 和 w 是互通的
* <v, w> 表示有向边，该边始于 v，终于 w

**注：不考虑重边和自回路**


图中的顶点有度的概念：

* 度(Degree): 所有与它连接点的个数之和
* 入度(Indegree): 存在于有向图中，所有接入该点的边数之和
* 出度(Outdegree): 存在于有向图中，所有接出该点的边数之和

图又分为有权图和无权图：

* 有权图：每条边具有一定的权重(weight)，通常是一个数字
* 无权图：每条边均没有权重，也可以理解为权为 1

图又分为连通图和非连通图：

* 连通图：所有的点都有路径相连
* 非连通图：存在某两个点没有路径可以相连

## (二) 图的表示

图的表示一般有两种:

### 邻接矩阵：

* 在 n 个顶点的图需要有 一个 n × n 大小的矩阵
* 在一个无权图中，每个位置值为 1 代表两点是相连的，0 代表两点是不相连的
* 在一个有权图中，每个位置值代表该两点之间的权重，0 代表该两点不相连
* 在无向图中，邻接矩阵关于对角线对称

### 邻接链表：

* 对于每个点，存储着一个链表，用来指向所有与该点相连的点
* 对于有权图来说，链表中元素值对应着权重

例如在无向无权图中：

![](/assets/2016-4-24-graphs/1.png)

在无向有权图中：

![](/assets/2016-4-24-graphs/2.png)

而在有向无权图中：

![](/assets/2016-4-24-graphs/3.png)

### 矩阵和链表的对比：

**在空间复杂度：**

* 邻接矩阵：O(|V|^2)
* 邻接链表：O(|V| + |E|)  (|E| 是图中所有边的个数)

**静态与动态：**

* 邻接矩阵是静态的，单向的，一旦创建完后就难以改变
* 邻接链表是动态的，在运行期间容易改变

## (三) 图的遍历

图的遍历就是要找到图中所有的点，一般有以下两种方法：

### 深度优先搜索：(Depth First Search, DFS)

基本思路：

深度优先遍历图的方法是，从图中某顶点v出发：  

1. 访问顶点v；  
2. 依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；  
3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。　

```java
//伪码实现，类似于树的先序遍历
public void DFS(Vertex v){
	visited[v] = true;
	for(v 的每个邻接点 W){
		if(!visited[W]){
			DFS(W);
		}
	}
}
```

### 广度优先搜索：(Breadth First Search, BFS)

广度优先搜索，可以被形象地描述为 "浅尝辄止"，它也需要一个队列以保持遍历过的顶点顺序，以便按出队的顺序再去访问这些顶点的邻接顶点。 

实现思路：

1. 顶点 v 入队列
2. 当队列非空时则继续执行，否则算法结束
3. 出队列取得队头顶点 v；访问顶点 v 并标记顶点 v 已被访问
4. 查找顶点 v 的第一个邻接顶点 col
5. 若 v 的邻接顶点 col 未被访问过的，则 col 继续
6. 查找顶点 v 的另一个新的邻接顶点 col，转到步骤 5 入队列，直到顶点 v 的所有未被访问过的邻接点处理完。转到步骤 2

要理解深度优先和广度优先搜索，首先要理解搜索步，一个完整的搜索步包括两个处理  

* 获得当前位置上，有几条路可供选择  
* 根据选择策略，选择其中一条路，并走到下个位置


**相当于在漆黑的夜里，你只能看清你站的位置和你前面的路，但你不知道每条路能够通向哪里。**搜索的任务就是，给出初始位置和目标位置，要求找到一条到达目标的路径。  

* **深度优先就是，从初始点出发，不断向前走，如果碰到死路了，就往回走一步，尝试另一条路，直到发现了目标位置。这种不撞南墙不回头的方法，即使成功也不一定找到一条好路，但好处是需要记住的位置比较少。**
 
* **广度优先就是，从初始点出发，把所有可能的路径都走一遍，如果里面没有目标位置，则尝试把所有两步能够到的位置都走一遍，看有没有目标位置；如果还不行，则尝试所有三步可以到的位置。这种方法，一定可以找到一条最短路径，但需要记忆的内容实在很多，要量力而行。**



## (四) 最短路径算法 (Shortest Path Algorithm)

### 无权图：

问题：在图中找到一个顶点到其他所有点的距离

对于初始点 v 来说，某个点的 d 代表该点到初始点的距离。

#### 基本方法：

基本步骤：

1. 将所有点的距离 d 设为无穷大
2. 挑选初始点 s，将 ds 设为 0，将 shortest 设为 0 
3. 找到所有距离 d 为 shortest 的点，查看它们的邻接链表的下一个顶点 w，如果 dw 的值为无穷大，则将 dw 设为 shortest + 1
4. 增加 shortest 的值，重复步骤 3，直到没有顶点的距离值为无穷大

例如：

![](/assets/2016-4-24-graphs/4.png)

#### 使用优先队列：

在之前的步骤 3 中，我们搜寻了所有距离 d 为 shortest 的点，这样效率会很低，取而代之，我们可以使用一个队列来进行优化缓存已经操作的元素

例如：

![](/assets/2016-4-24-graphs/5.png)

### 有权图：

在有权图中，常见的最短路径算法有 Dijkstra 算法和拓扑排序算法

#### Dijkstra 算法:

Dijkstra 算法适用于权值为正的的图中。

**使用一个反序的优先队列来存储顶点，按照它们路径花费大小进行升序。**

算法步骤：

1. 将所有边初始化为无穷大
2. 选择一个开始的顶点，添加到优先队列中
3. 对于该点的所有邻接顶点进行判断，如果到该点的距离小于原先的值，则将该值更新
4. 将该点所有邻接顶点添加到优先队列中
5. 从优先队列中挑选一个路径值最小的顶点，将其弹出，作为新的顶点，重复步骤 3，4，5
6. 直到所有点都被处理过一次

例如：

![](/assets/2016-4-24-graphs/6.png)

首先选取 v0 作为起始点，添加到优先队列中，将v0弹出，然后对 v0 邻接点进行判断，由于一开始所有边都为无穷大，那么 <v0, v1> 和 <v0, v3> 都更新，值为 2 和 1，按路径大小升序将v3、v1添加到优先队列

![](/assets/2016-4-24-graphs/7.png)

之后将 v3 弹出，对所有 v3 邻接点进行值的更新，并将所有邻接点按路径大小升序添加到优先队列中，若遇到值相同，则无所谓其先后顺序

![](/assets/2016-4-24-graphs/8.png)

![](/assets/2016-4-24-graphs/9.png)

重复这样的过程，直到所有的点都被处理过，则算法终止

**Dijkstra 算法性能：**

* 时间复杂度：O(|V|^2 + |E|)
* 对于密集图来说：O(|V|^2)
* 对于稀疏图来说：O(|E|log|V|)

**Dijkstra 算法适合于权值为正的情况下，若权值为负则不能使用，因为出现死循环。这时候我们需要计算每个顶点被处理的次数，当某个顶点已经处理过的话，就跳出该循环。**

#### 拓扑排序算法：(Topological Ordering Algorithm)
	
对一个有向无环图 G(Directed Acyclic Graph简称DAG)进行拓扑排序，是将图中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边(u,v)∈E(G)，则 u 在线性序列中出现在 v 之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。

一般有环图不能使用此方法，比如

![](/assets/2016-4-24-graphs/10.png)

算法步骤:

1. 用一个计数器来标识每个顶点，该值存储该顶点的入度
2. 找到一个入读为 0 的点 v，若不存在，则该图必然是有环图，则算法终止。
3. 将 v 添加到链表中，然后将 **v 的所有邻接点**(不是所有点的计数器)的计数器 - 1(即入度 - 1)
4. 循环步骤 2、3 直到所有顶点都出现在链表中

例如：

![](/assets/2016-4-24-graphs/11.png)

![](/assets/2016-4-24-graphs/12.png)

![](/assets/2016-4-24-graphs/13.png)

![](/assets/2016-4-24-graphs/14.png)

## (五) 最小生成树 (Minimum Spanning Trees MST)

图必须是连通的，才存在最小生成树。一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。

### 特点：

* 该树是连通的
* 权值之和最小
* 边数比顶点个数少 1

### 存在个数：

**最小生成树在一些情况下可能会有多个。**

* 当图的每一条边的权值都相同是，该图的所有生成树都是最小生成树
* 如果图的每一条边的权值都互不相同，那么最小生成树将只有一个

比如：

![](/assets/2016-4-24-graphs/15.png)

生成最小生成树的算法一般有两种，分别是普里姆算法和 Kruskal 算法

### 普里姆算法 (Prim 算法):

算法步骤：

1. 输入：一个加权连通图，其中顶点集合为 V，边集合为 E
2. 初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空
3. 在集合 E 中选取权值最小的边<u, v>，其中u为集合 Vnew 中的元素，而 v 不在 Vnew 集合当中，并且 v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）
4. 将 v 加入集合 Vnew 中，将 <u, v> 边加入集合 Enew 中
5. 重复步骤 3、4，直到 Vnew = V

时间复杂度：O(|V|^2)

### Kruskal 算法：

**需要一个集合用来升序存储所有边**

算法步骤：

1. 先构造一个只含 n 个顶点，而边集为空的子图。
2. 从边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图(也就是说，将这两个顶点分别所在的两棵树合成一棵树)，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之
3. 重复步骤 2，直到所有点连通

时间复杂度：O(|E|log|V|)

例如：

![](/assets/2016-4-24-graphs/16.png)

在对所有边进行排序之后，我们得到一个边集合，从边集合中取出最小权的边 AD

![](/assets/2016-4-24-graphs/17.png)

剩下的边中寻找。我们找到了 CE。这里边的权重也是 5，依次类推我们找到了 6,7,7

![](/assets/2016-4-24-graphs/18.png)

尽管现在长度为 8 的边是最小的未选择的边。但是他们已经连通了

![](/assets/2016-4-24-graphs/19.png)

最后就剩下 EG 和 FG 了。当然我们选择了 EG。

## (六) 图论应用

* 旅行推销员问题:一个人如何坐车才能花最短路径去所有城市
* 如何建路便宜且使所有城镇相连
* 使用最少的电线建立一个网络
* 项目管理


1