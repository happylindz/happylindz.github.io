---
layout:     post
title:      "数据结构 - 排序"
date:       2016-04-24 12:00:00
author:     "Lindz"
header-img: "img/10.jpg"
tags:
    - 数据结构
---

## (一) 前言：

> 有很多数据结构可以用来存储这些未排序的数据，下面主要使用数组。

基本问题：将一组未排序的数据进行排序 (升序或者降序)

可以分为两大类：

* 基于地址的排序 (address-based sorting)
* 基于比较的排序 (comparison-based sorting)

![](/assets/2016-04-25-sort/1.png)

## (二) 基于地址的排序

基于地址的排序有：Proxmap 排序和基数排序

### Promap 排序

具体我也不是很理解，感兴趣可以看: [Proxmap sort - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Proxmap_sort)

这个排序是桶排序和基数排序的改进，基本思路是使用哈希函数将一个数组的数据分割到一些子数组(buckets)，就像下图这样：

![](/assets/2016-04-25-sort/2.png)

![](/assets/2016-04-25-sort/3.png)

这个排序把数字分区了,然后给出一个所谓的键,例如它规定 0-9 都入 0 号桶，10-19 都入 1 号桶，这样桶覆盖的范围将增大 10 倍,这在某种情况下是很有用的。

这个算法十分的复杂，并且只能处理特定类型的数据。

### 基数排序 (Radix Sort)

基数排序是稳定的排序算法，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。

我们假设我们需要排序的元素： ```73, 22, 93, 43, 55, 14, 28, 65, 39, 81```

1.首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：

```
0
1 81
2 22
3 73 93 43
4 14
5 55 65
6
7
8 28
9 39
```

接下来将这些桶子中的数值重新串接起来，成为以下的数列：```81, 22, 73, 93, 43, 14, 55, 65, 28, 39```

2.接着再进行一次分配，这次是根据十位数来分配：

```
0
1 14
2 22 28
3 39
4 43
5 55
6 65
7 73
8 81
9 93
```

3. 接下来将这些桶子中的数值重新串接起来，成为以下的数列：```14, 22, 28, 39, 43, 55, 65, 73, 81, 93```
4. 这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。

时间复杂度：O(n),但是基数排序有个问题：就是排序 n 个元素需要至少 2n 的空间
	
## (三) 基于比较的排序

从前面的图中，我们可以知道常见的基于比较的排序有 冒泡排序，插入排序(树排序)，选择排序，归并排序和快速排序，下面就一一介绍。

### 冒泡排序 (Bubble Sort)

一种非常简单但性能十分糟糕的排序算法，基本思路：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。则第一轮过后最后的元素应该会是最大的数
3. 除了最后一个最大的元素，前面 n - 1 个元素重复步骤 2
4. 直到执行元素只剩一个，那么它就是最小的元素

代码实现：

```java
for (int i = arr.length; i > 0; i--) { 
	for (int j = 1; j < i; j++) { 
		if (arr[j-1] > arr[j]) {
			temp = arr[j-1]; 
			arr[j-1] = arr[j]; 
			arr[j] = temp; 
		} 
	}
}
```

时间复杂度: O(n^2)，优点就是它的简单性

### 选择排序 (Selection Sort)

**选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是直到全部待排序的数据元素排完。每一次从待排序的数据元素中选出最大的一个元素，存放在序列的起始或末尾位置。**

基本步骤：(升序排序)

1. 初始化 PQLast 到优先队列的最后一个位置
2. 从头到位置 PQLast 中寻找最大的元素，记录它的位置 front
3. 交换位置 front 和PQLast 中的元素
4. 将 PQLast - 1，然后重复 步骤 2、3、4

比如：

![](/assets/2016-04-25-sort/4.png)

front 记录的是未排序的数字中最大元素的位置，而 PQLast 记录的是已排好序的位置

主要的缺点在于每次找到最大元素的时候需要遍历整个未排序的数组，这样效率就会变得很低。

假设有 n 个元素要进行排序，那么第一次排序需要比较 n - 1 次才能找到最大(最小元素)，第二次则需要 n - 2 次，依次类推，所以一共需要```(n-1) + (n-2) + ... + 2 + 1 = (n (n-1)) / 2```次比较，而交换元素需要 ```n - 1```次，所以一共操作次数为 ```1/2n^2 + 1/2n - 1```

由上可得: 时间复杂度: O( n^2 )

* 尽管它的性能较差，但是它的好处在于他的简单性
* 对于数据量较少时，选择排序会优于 O(nlogn) 的算法，这是因为  O(nlogn) 的算法一般比较复杂而且需要进行递归，而递归的成本较高
* 选择排序优于冒泡排序，其交换的次数较少，尽管时间复杂度一样，


另外选择排序是不稳定的排序方法（比如序列 [5，5，3] 第一次就将第一个 [5] 与 [3] 交换，导致第一个 5 挪动到第二个 5 后面）。

### 插入排序 (Insertion Sort)

**插入排序的基本思想是：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。**

基本原理：

将n个元素的数列分为已有序和无序两个部分，如下所示：

```
有序：{a1}，无序：{a2，a3，a4，…，an}
有序：{a1⑴，a2⑴}，无序：{a3⑴，a4⑴ …，an⑴}}
…
有序：{a1(n-1），a2(n-1) ，…}, 无序：{an(n-1)}
```

每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。

例如：我们要对数组 4，3，1，2 进行排序

![](/assets/2016-04-25-sort/5.png)

时间复杂度为: O( n^2 )

### 希尔排序 (Shell Sort)

希尔排序又称为递减增量排序 (Diminishing Increment Sorting)，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

**希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。**

让我们来看一个简单的例子：

假设我们准备排序的的数组是 [11, 2, 7, 1, 3, 5]

首先需要选取增量,例如增量是 3 和 1 (第一步分成三组,第二步分成一组),那么待排数组分成了以下三个虚拟组:[11, 1]、[2, 3] 和 [7, 5] 即增量值是 3，则每隔三个数取一个,每隔三个再取一个,这样取出来的数字放到一组,

**把它们当成一组,但不实际分组,只是当成一组来看,所以上边的"组"实际上并不存在,只是为了说明分组关系**

对以上三组分别进行插入排序变成下边这样：[1 11] [2 3] [5 7]，之后将这些元素放回对应的原位，此时待排的数组就变成了 [1, 2, 5, 11, 3, 7]，然后根据下一个增量再待排数组进一步排序

希尔排序的关键在于如何选取增量，选完增量分完组，之后的内容就跟插入排序差不多，一般增量的选取的规则如下：floor(n/2) floor 为向下取整，比如我们待排的元素个数为 10，则选取的增量为 5, 2, 1，最后一个增量必须为 1，不然就不能愉快地玩耍了。

时间复杂度: O( n^1.25 )

### 归并排序 (Merge Sort)

该算法是采用分治法（Divide and Conquer)，基本思想是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。

例如：我们要将 [5, 1, 4, 2, 10, 3, 9, 15]进行排序，首先我们需要将这个数组进行拆分 (Divide)

![](/assets/2016-04-25-sort/6.png)

然后在将其合并，

![](/assets/2016-04-25-sort/7.png)

那么具体如何将两个数组进行合并成一个数组，这样的操作我们称之为归并操作。基本工作原来如下：

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤 3 直到某一指针超出序列尾，此时将另一序列剩下的所有元素直接复制到合并序列尾

如下图：创建了 Aptr 和 Bptr 指针指向当前比较的位置 

![](/assets/2016-04-25-sort/8.png)

#### 时间复杂度分析：

假设需要排序的元素个数 n 是 2 倍数，这样我们就可以将它均分

* 当元素个数为 1 时，那么 ```T(1) = 1```
* 除此之外处理 n 个元素的时间等于一半元素(n/2)各自的处理时间 + 这 n 个元素的比较，所以 ```T(n) = 2T(n/2) + n```
* 所以根据迭代地(```T(n/2)/(n/2) = T(n/4)/(n/4) + 1```,```T(n/4)/(n/4) = T(n/8)/(n/8) + 1```)去替代最终可以得出 ```T(n)/n = T(1)/1 + log n```，故 ```T(n) = n log 2 n + n```
* 所以归并排序的时间复杂度: O( nlogn )

**尽管它的性能不错，但是它几乎很少被运用在主内存的排序，因为它在排序的过程中会占用大量的内存，造成资源的浪费。**

### 快速排序 (Quick Sort)

**快速排序是对冒泡排序的一种改进，它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。**

基本步骤：

1. 选取数组中中间的元素，创建两个新数组，对于剩下其他的元素与该元素进行比较如果比他小，则放在左边的数组，比它大则放到右边的数组
2. 对新的创建的数组重复执行步骤 1
3. 直到数组的元素个数为 0 或者 1，则返回
4. 最终将所有数组合并

例如：需要排序的数组为 [5, 1, 4, 2, 10, 3, 9, 15, 12]

![](/assets/2016-04-25-sort/9.png)

上述的方式中需要创建两个新的数组，如果数据量很大的话这样就比较浪费资源，对此我们可以采用下面这种改进的方式：

1. 将数组中最中间元素 swapPos 与第一个元素进行交换
2. 改变swapPos = 第一元素位置 + 1
3. 对于 swapPos 上的元素来说，如果他比第一个元素来的小，则 swapPos + 1，如果它比第一个元素大，则寻找后面的元素，若出现比第一个元素小的元素，则与它交换。
4. 重复执行步骤 3，swapPos 以及后面的元素都比第一个元素来的大，最后交换第一个元素和 swapPos - 1 位置的元素

具体实现过程：需要排序的数组仍为 [5, 1, 4, 2, 10, 3, 9, 15, 12]

![](/assets/2016-04-25-sort/10.png)

![](/assets/2016-04-25-sort/11.png)

最后将 10 和 25 进行交换，那么 10 之前的数就比 10 来的小，10 之后的数就比 10 来的大，之后将 10 前后的元素分别看做一个新的数组，继续执行上述的操作。

#### 时间复杂度分析：

由已知我们可得出：

* ```T(0) = T(1) = 1```
* 设 i 为最后分到左边数组的元素个数，则 ```T(n) = T(i) + T(n - i - 1) + cn```(cn是对这个 n - 1 个元素进行比较分类)

**在最坏的情况下：**

* ```T(n) = T(n - 1) + cn```，故根据递归可得 ```T(n) = T(1) + c(n + ... + 2)```
* 所以最坏时间复杂度: O(n^2)(即每次取最中间的元素都是该数组中最小的元素)，此时快速排序算法就退化成冒泡排序了

**在最好的情况下：**

* 左右两边的数组元素个数是平均的，即 ```T(n) = 2T(n/2) + cn```，
* 递归可得：```T(n) = cnlog2n + n```，时间复杂度为 O(nlogn)


**平均时间复杂度为 O(nlogn)，具体计算过程如下：**

1. 我们假设 i 的取值有 0，1，2... (n - 1) 共 n 中情况，且每种情况有 1/n 的可能
2. 所以有前面式子可推出：```T(n) = 2(T(0) + T(1) + ... + T(n–1))/n + cn```
3. 两边乘 n 可得出：```nT(n) = 2(T(0) + T(1) + ... + T(n–1)) + cn```
4. 将 n 替换为 n - 1 得出：```(n–1)T(n–1) = 2(T(0) + ... + T(n–2)) + c(n–1) 2```
5. 式子 3 减 式子 4 可得：```nT(n) – (n–1)T(n–1) = 2T(n–1) + 2cn – c``` 整理可得 ```T(n)/(n+1) = T(n–1)/n + 2c/(n+1)```
6. 递归可得：```T(n)/(n+1) = T(1)/2 + 2c(1/3 + 1/4 + ... + 1/(n+1))```
7. 所以时间复杂度为: O(nlogn)

**当排序的元素个数少于 20 个时，快速排序表现的比像选择排序那样的简单排序来的差，因为快速排序需要递归，会有很多小的情况(个数为 1 的数组)发生。所以当数据量少于 10 的时候，我们可以改用一种非递归的算法来进行排序。**

参考链接：

* [基数排序_百度百科](http://baike.baidu.com/link?url=5nCChgEofwidfeon-qFxTgRwscvNhuaI7E_Oun29C4U-9LvP19jRNvP8dIeFDOsHPGL3RISKlvDMqzEp0fq9B_)
* [八大排序算法 - guisu 程序人生 逆水行舟，不进则退 - 博客频道 - CSDN.NET](http://blog.csdn.net/hguisu/article/details/7776068)
