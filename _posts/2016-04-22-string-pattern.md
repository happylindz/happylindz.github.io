---
layout:     post
title:      "数据结构 - 字符串匹配"
date:       2016-04-22 12:00:00
author:     "Lindz"
header-img: "img/10.jpg"
tags:
    - 数据结构
---

字符串匹配是计算机的基本任务之一，那么计算机如何在一个字符串中查找匹配另一个字符串，比如：

![](/assets/2016-04-22-string-pattern/11.png)

我们需要在 text 字符串中寻找是否出现过 pattern，这个在计算机中具有广泛的应用，所以一个高效的算法就显得十分重要。

**下面就介绍三种方法：**

## 简单匹配：

第一种匹配方式简单粗暴，基本步骤：

1. 在 text 中从左往右匹配 pattern
2. 一旦出现不匹配时，则匹配起点向右移一位，并重新匹配，若匹配成功则返回
3. 若一直到字符串的尽头都没有匹配成功，则说明 text 中不包含 pattern

比如：

![](/assets/2016-04-22-string-pattern/12.png)

这样的算法显然性能很差，在最坏的情况下，这样的算法需要执行 t × p 次判断才能得出结果。( t 为 text 长度，p 为 pattern 长度)

那么有没有更好的算法？

## KMP 算法:

KMP 算法是由 Knuth、Morris 和 Pratt 三个人共同发明的。

前面在介绍简单匹配的时候，每次重新匹配仅向右移动一位，而 KMP 算法在每次不匹配的时候会可能多地向右移动位数。

比如：

![](/assets/2016-04-22-string-pattern/13.png)

**这样跳跃式地移动位数就可能会出现问题，如果已匹配字符串中包含两个 pattern 的前缀，那么就有可能出现漏掉的匹配项，比如上图中的第 3、4 行，并没有从 C 的位置重新开始匹配，因为已经匹配的字符串中包含两个 ABC。**

那么问题来了，我们如果确定这个偏移量呢？假设我们在字符串 "BBC ABCDAB ABCDABCDABDE" 查找搜索词 "ABCDABD"。那么我们可以针对搜索词，算出一个《部分匹配表》，至于这个表是怎么算出来的，后面再介绍

![](/assets/2016-04-22-string-pattern/1.png)

![](/assets/2016-04-22-string-pattern/2.png)

已知空格与 D 不匹配时，前面六个字符 "ABCDAB" 是匹配的。查表可知，最后一个匹配字符 B 对应的"部分匹配值"为 2，因此按照下面的公式算出向后移动的位数：

```移动位数 = 已匹配的字符数 - 对应的部分匹配值```

因为 6 - 2 等于4，所以将搜索词向后移动4位。

再比如：

![](/assets/2016-04-22-string-pattern/3.png)

因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（"AB"），对应的"部分匹配值"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。

![](/assets/2016-04-22-string-pattern/4.png)

逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位。(如果需要匹配字符串中所有符合的匹配项)

完整的实现过程：

![](/assets/2016-04-22-string-pattern/1.gif)

那么那个《部分匹配表》是怎么得到的？

首先，要了解两个概念："前缀" 和 "后缀"。 "前缀" 指除了最后一个字符以外，一个字符串的全部头部组合；"后缀" 指除了第一个字符以外，一个字符串的全部尾部组合。

![](/assets/2016-04-22-string-pattern/5.png)

"部分匹配值" 就是 "前缀" 和 "后缀" 的最长的共有元素的长度。以 "ABCDABD" 为例。

* "A" 的前缀和后缀都为空集，共有元素的长度为 0；
* "AB" 的前缀为 [A]，后缀为 [B]，共有元素的长度为 0；
* "ABC" 的前缀为 [A, AB]，后缀为 [BC, C]，共有元素的长度 0；
* "ABCD" 的前缀为 [A, AB, ABC]，后缀为 [BCD, CD, D]，共有元素的长度为0；
* "ABCDA" 的前缀为 [A, AB, ABC, ABCD]，后缀为 [BCDA, CDA, DA, A]，共有元素为 "A"，长度为 1；
* "ABCDAB" 的前缀为 [A, AB, ABC, ABCD, ABCDA]，后缀为 [BCDAB, CDAB, DAB, AB, B]，共有元素为 "AB"，长度为 2；
* "ABCDABD" 的前缀为 [A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为 [BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为 0。

**"部分匹配"的实质是，有时候，字符串头部和尾部会有重复。比如，"ABCDAB" 之中有两个 "AB"，那么它的"部分匹配值"就是 2（"AB"的长度）。搜索词移动的时候，第一个 "AB" 向后移动 4 位（字符串长度-部分匹配值），就可以来到第二个"AB"的位置**

## Boyer-Moore 算法

前面介绍了 KMP 算法，但是，它并不是效率最高的算法，实际采用并不多。各种文本编辑器的"查找"功能（Ctrl+F），大多采用Boyer-Moore算法。Boyer-Moore算法不仅效率高，而且构思巧妙，容易理解。

假定字符串为"HERE IS A SIMPLE EXAMPLE"，搜索词为"EXAMPLE"。

![](/assets/2016-04-22-string-pattern/6.png)

开始比较：

![](/assets/2016-04-22-string-pattern/7.png)

首先，"字符串"与"搜索词"头部对齐，从尾部开始比较。

这是一个很聪明的想法，因为如果尾部字符不匹配，那么只要一次比较，就可以知道前7个字符肯定不是要找的结果。

我们看到，"S" 与 "E" 不匹配。这时，"S" 就被称为"坏字符"（bad character），即不匹配的字符。我们还发现，"S" 不包含在搜索词 "EXAMPLE" 之中，这意味着可以把搜索词直接移到 "S" 的后一位。

![](/assets/2016-04-22-string-pattern/8.png)

依然从尾部开始比较，发现 "P" 与 "E" 不匹配，所以 "P" 是"坏字符"。但是，"P" 包含在搜索词 "EXAMPLE" 之中。所以，将搜索词后移两位，两个 "P" 对齐。

由此总结出"坏字符规则"：

```后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置```

如果"坏字符"不包含在搜索词之中，则上一次出现位置为 -1。

以 "P" 为例，它作为"坏字符"，出现在搜索词的第 6 位（从 0 开始编号），在搜索词中的上一次出现位置为 4，所以后移 6 - 4 = 2 位。再以前面第二步的 "S" 为例，它出现在第 6 位，上一次出现位置是 -1（即未出现），则整个搜索词后移 6 - (-1) = 7 位。

以上是 "坏字符规则"，还有一个 "好后缀规则"：

```后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置```

计算时，位置的取值以"好后缀"的最后一个字符为准。如果"好后缀"在搜索词中没有重复出现，则它的上一次出现位置为 -1。

![](/assets/2016-04-22-string-pattern/9.png)

比较前面一位，"MPLE" 与 "MPLE" 匹配。我们把这种情况称为"好后缀"（good suffix），即所有尾部匹配的字符串。注意，"MPLE"、"PLE"、"LE"、"E" 都是好后缀。

![](/assets/2016-04-22-string-pattern/10.png)

比较前一位，发现 "I" 与 "A" 不匹配。所以，"I" 是 "坏字符"。根据"坏字符规则"，此时搜索词应该后移 2 -（-1）= 3 位。

而根据 “好后缀规则"，所有的"好后缀"（MPLE、PLE、LE、E）之中，只有 "E" 在 "EXAMPLE" 之中出现两次，所以后移 6 - 0 = 6 位。

**可以看到，"坏字符规则"只能移 3 位，"好后缀规则"可以移 6 位。所以，Boyer-Moore 算法的基本思想是，每次后移这两个规则之中的较大值。**

更巧妙的是，这两个规则的移动位数，只与搜索词有关，与原字符串无关。因此，可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。

完整的搜索过程：

![](/assets/2016-04-22-string-pattern/2.gif)

参考链接:

* [字符串匹配的KMP算法 知识库 博客园](http://kb.cnblogs.com/page/176818/)
* [字符串匹配的Boyer-Moore算法 知识库 博客园](http://kb.cnblogs.com/page/176945/)
