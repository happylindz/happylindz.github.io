---
layout:     post
title:      "数据结构 - 二叉堆及优先队列"
date:       2016-04-21 12:00:00
author:     "Lindz"
header-img: "img/7.jpg"
tags:
    - 数据结构
---

> 前面在介绍到队列的时候，CPU 在完成任务的调度的时候总是先进先出，那么如果这时候事件之间是有优先级的关系，优先级高的先做，优先级低的后做，这就是我们后面介绍的二叉堆和优先队列的核心思想。

## (一) 基本概念

二叉堆是一种完全二叉树的堆，二叉堆一般有两种形式：最大堆(MaxHeap)和和最小堆(MinHeap)。

下面我们都以最大堆为例，它一般有以下特性：

1. 每一个节点的值都比它的子节点值大
2. 它类似于完全二叉树，所以除了叶子层，其余层都是满的，且叶子层节点都是从左向右依次排满

## (二) 基本操作

### 1、插入：

在插入一个元素到二叉堆：

1. 该节点被创建在叶子层从左往右中可被插入的位置
2. 如果需要该元素将会 "冒泡" 直到堆重新调整（如果比其父节点大，就交换该节点与父节点）

例子：将元素 45 插入到二叉堆中

![](/assets/2016-04-21-binary-heap/1.gif)

### 2、删除：

从二叉堆中删除根节点：

1. 最后一个元素首先被替换到根节点
2. 比较新根节点与它的儿子节点，如果都比儿子节点小，那么就与儿子节点中大的元素进行交换
3. 从新的位置继续判断，直到重新调整好二叉堆

例子：将根元素从二叉堆中删除

![](/assets/2016-04-21-binary-heap/2.gif)

### 3、存储方式：

可以直接使用一个树组用来存储二叉堆：因为二叉堆 (完全二叉树) 是很有规律性的。

比如: 这里有一棵这样的二叉堆

![](/assets/2016-04-21-binary-heap/1.png)

我们可以用这样的树组来表示：

![](/assets/2016-04-21-binary-heap/2.png)

 此时，遍历该二叉堆将会非常容易，因为索引值为 i 的节点：

* 其左子节点的索引值为 2i
* 其右子节点的索引值为 2i + 1
* 其父节点的索引值为(向下取整) [i/2]

## (三) 优先队列

### 基本概念：

普通队列是一种先进先出的数据结构，元素在队列末尾追加，从队列头删除。**而在优先队列中，元素被赋予优先级，当访问元素的时候，具有最高优先级的元素最先删除，即具有 largest-in, first-out 的特性。**

它一般具有以下特性：

1. 每一元素被赋予一定的权重
2. 每次删除权重最高的元素

**优先队列可以理解为二叉堆的一种实现，一种表现形式。**

### 基本操作：

* 插入： 通过它的权重添加一个元素，可能会出现在队列中任何位置
* 删除： 删除队列中权重最大的

### 实现方式：

#### 1、未排序的数组：（不推荐）

* 元素被保存在一个乱序的数组中(即不通过权重来进行排序)
* 插入元素时会被添加到队列的末尾
* 删除元素时：先找到权重最高的元素，移除它，然后将其后面的元素依次填充到前一元素的位置

时间复杂度：

* 插入 - 元素总是插在尾部：O(1)
* 删除 - 查找最大(最小)关键字 O(n) - 向前依次填充: O(n)

例子：

![](/assets/2016-04-21-binary-heap/3.png)

这样做效率很低，如果后面元素特别多，那么替换的过程将会非常耗时

#### 2、排序的链表：

* 元素被保存在一个有序的链表中，优先级高的在表头
* 插入元素时：先创建一个节点，然后找到它的权重所介于的位置，然后重新调整新节点与原本前后两节点的位置，将其插入 (如果其权重最高，那么将该节点作为新的表头)

时间复杂度：

* 插入 - O(n)
* 删除 - 弹出表头 O(1)

#### 3、二叉堆： 这个方法前面已经介绍，这里不再赘述 (推荐)

时间复杂度:

* 插入 - O(log(n))
* 删除 - O(log(n))



